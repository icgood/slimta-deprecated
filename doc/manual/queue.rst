
Queue Services
==============

.. toctree::
   :hidden:

   storage

The *queue* of an *MTA* does little on its own, it takes in email messages from
an :doc:`edge <edge>` service and intermittently attempts delivery with a
:doc:`relay <relay>` service until successful. This keep-trying-until-successful
method is defined by the RFC to ensure eventual delivery of the message. The
queue is also responsible for generating *bounces* in the event that the message
has been deemed undeliverable.

In *slimta*, the queue service waits for requests using a server :doc:`bus
<bus>`.  Each request contains messages that the queue messages stores using a
:mod:`storage engine <slimta.storage>`. Once the messages have been stored,
responses are returned describing whether or not the messages were queued
successfully.

Generally, upon reception and storage, the queue service will make an immediate
attempt at delivery by sending a request to a :doc:`relay <relay>` service. The
relay will return a response that the queue will use to decide what to do next.
If the relay returns a *2xx* code, the queue will consider the message delivered
and remove it from storage. If the relay returns a *5xx* (permanent error) code,
a *bounce* message is generated and queued to notify the sender of the failure,
and the message is removed from storage. If the relay returns a *4xx* (transient
error) code, the message remains in queue to be retried.

Creating a Queue Object
"""""""""""""""""""""""

Creating a :mod:`~slimta.queue` object requires three things: a server
:mod:`~slimta.bus` connected to an :doc:`edge <edge>` service, a client
:mod:`~slimta.bus` connected to a :doc:`relay <relay>` service, and a
:mod:`storage engine <slimta.storage>` object.

::

   local edge_server, edge_client = slimta.bus.new_local()
   local relay_server, relay_client = slimta.bus.new_local()
   local storage = slimta.storage.redis.new("localhost")

   local queue = slimta.queue.new(edge_server, relay_client, storage)

As described in :doc:`bounces`, you can change the way a *bounce* message is
generated by the queue by creating a :mod:`~slimta.bounce` object and using
:func:`~slimta.queue.set_bounce_builder()`::

   local bounce_builder = slimta.message.bounce.new(
      "postmaster@server.example.com"
   )

   queue:set_bounce_builder(bounce_builder)

Retry Algorithms
""""""""""""""""

One of the most important functions of the queue is retrying messages after
transient failure. These include when the server returns a *4xx* reply, or when
the remote host could not be reached, which is an implied *451*. It is
completely up to the *MTAs* logic to decide how long to wait, which is where
retry algorithm functions come in.

By default, :mod:`~slimta.queue` objects will **not** attempt redelivery but
will immediately fail and *bounce* the message, which is hardly desirable.
Setting a new retry algorithm function lets you define when messages are
retried, and when they should be failed::

   local function retry_algorithm(message)
       local n = message.attempts
       if n <= 5 then
           return os.time() + (600*n)
       else
           return nil
       end
   end

   queue:set_retry_algorithm(retry_algorithm)

In this example, a message will be delay ten minutes per previous attempt. That
is, the first delay will be 10 minutes, then 20 minutes, 30 minutes, etc. After
5 retries, the ``nil`` return tells the queue object to fail and *bounce* the
message.

